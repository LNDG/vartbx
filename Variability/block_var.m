%_______________________________________________________________________
%
% Compute condition-wise variability with the boxcar model
%_______________________________________________________________________
%
% Input
%
% job | batch job generated by tbx_cfg_variability (struct)
%
%_______________________________________________________________________
%
% Output
%
% output | batch job with result file paths (struct)
%
%_______________________________________________________________________
%
% This file is part of the Variability Toolbox for SPM
% Published by the Lifespan Neural Dynamics Group
% Provided under the GNU General Public License
% See LICENSE for terms and conditions

function output = block_var(job)

  cfg = shared_config;

  %%
  %% sanitize function parameters
  %%
  if ~exist('job','var') || isempty(job)
    error('Missing or empty parameter: job')
  else
    if ~isstruct(job)
      error('Invalid type: job (requires struct)')
    end
  end

  if ~isfield(job,'modeltype') || isempty(job.modeltype)
    error('Missing or empty field: job.modeltype')
  else
    if ~isstr(job.modeltype)
      error('Invalid type: job.modeltype (requires string)')
    end
    if ~strcmp(job.modeltype, 'boxcar')
      error('Invalid content: job.modeltype (requires ''boxcar'')')
    end
  end

  if ~isfield(job,'modelmat') || isempty(job.modelmat)
    error('Missing or empty field: job.modelmat')
  else
    if iscell(job.modelmat) && numel(job.modelmat) == 1 && ischar(job.modelmat{1})
      model_file = job.modelmat{1};
    elseif ischar(job.modelmat)
      model_file = job.modelmat;
    else
      error('Invalid type: job.modelmat (requires string)')
    end
    if ~exist(model_file,'file')
      msg = sprintf('Missing file: %s ', model_file);
      error(msg)
    end
  end

  if ~isfield(job,'metric') || isempty(job.metric)
    error('Missing or empty field: job.metric')
  else
    if ~iscell(job.metric) && ~ischar(job.metric)
      error('Invalid type: job.metric (requires string)')
    end
    if ~ismember(cfg.metric, job.metric)
      msg = sprintf('Invalid content: job.metric\n');
      msg = [msg 'Requires one of the following: '];
      msg = [msg sprintf('''%s'', ',cfg.metric{:})];
      msg = msg(1:end-2);
      error(msg)
    end
    if iscell(job.metric)
      metric = job.metric;
    else
      metric = {job.metric};
    end
  end

  if ~isfield(job,'resultprefix') || isempty(job.resultprefix)
    error('Missing or empty field: job.resultprefix')
  else
    if ~ischar(job.resultprefix)
      error('Invalid type: job.resultprefix (requires string)')
    end
  end

  if ~isfield(job,'resultdir') || isempty(job.resultdir)
    error('Missing or empty field: job.resultdir')
  else
    if iscell(job.resultdir) && numel(job.resultdir) == 1 && ischar(job.resultdir{1})
      base_dir = job.resultdir{1};
    elseif ischar(job.resultdir)
      base_dir = job.resultdir;
    else
      error('Invalid type: job.resultdir (requires string)')
    end
    if ~exist(base_dir,'dir')
      msg = sprintf('Missing directory: %s ', base_dir);
      error(msg)
    end
  end

  %%
  %% read model specification
  %%
  model_job = load(model_file);
  matlabbatch = model_job.matlabbatch;
  fmri_spec = matlabbatch{1}.spm.stats.fmri_spec;

  if isfield(job,'testing') && job.testing
    fmri_spec.sess = fmri_spec.sess(1);
  end

  sess = fmri_spec.sess;
	condition = {sess(1).cond.name};
  job_result_files = [];

  if ~isempty(job.resultprefix)
    prefix = [job.resultprefix '_'];
  else
    prefix = '';
  end

  %%
  %% apply mask if specified
  %%
	mask_file = char(fmri_spec.mask);
  subj_hdr = spm_vol([sess(1).scans{1} ',1']);
  subj_dim = subj_hdr.dim;
	if not(isempty(mask_file))
		mask_hdr = spm_vol(mask_file);
		if not(spm_check_orientations([subj_hdr, mask_hdr]))
			error('Scans differ in orientation, dimension or voxel size.');
		end
		mask_img = spm_read_vols(mask_hdr);
		coord = find(mask_img);
	else
    coord = 1:prod(subj_dim);
	end

  %%
	%% compute scan indices per condition block
  %% condition x session x block
  %%
	cond_idx = block_load_index(fmri_spec);

  %%
	%% workaround for pixel shifts with default renderer
  %%
  if cfg.gui
	  progress_window = spm_figure('GetWin','Interactive');
	  set(progress_window, 'Renderer','OpenGL');
  end

  %%
  %% load image data, residualize if necessary and merge blocks
  %%
	cond_img = block_merge(sess, cond_idx, coord);

  %%
	%% actual variability computation
  %%
  %% cond_img: conditions x blocks x scans x voxels
  %%

  input_file = sess(1).scans{1};
  num_step = numel(condition) * numel(metric);
  cur_step = 0;

  label_text = 'Saving Results';

  if cfg.gui
	  label = [cfg.format label_text];
	  spm_progress_bar('Init', 100, label, '', 't');
  else
	  fprintf('%+*s', cfg.pad, label_text)
    prog_bar = shared_progbar(num_step);
  end

	for c = 1:numel(condition)
    for m = 1:numel(metric)
      
      if numel(metric) > 1
        result_dir = fullfile(base_dir, job.modeltype, metric{m});
      else
        result_dir = base_dir;
      end

      if ~exist(result_dir, 'dir')
        mkdir(result_dir)
      end

      switch metric{m}
        case {'var','sd'}
          img = detrend(cond_img{c});
        case {'mssd','sqrt_mssd'}
          img = cell2mat(cond_img{c});
      end

      result_voxel = shared_var(img, metric{m});
      result_image = zeros(subj_dim);
      result_image(coord) = result_voxel;

      result_file = [prefix condition{c} '.nii'];
      result_file = fullfile(result_dir, result_file);
      shared_save_nifti(input_file, result_file, result_image)
      job_result_files{end+1} = result_file;
      cur_step = cur_step + 1;
      
      if cfg.gui
    		progress = round(100 * cur_step / num_step);
  		  spm_progress_bar('Set', progress);
      else
        prog_bar.update(cur_step);
      end

    end % metric
	end % condition

  if not(cfg.gui)
    prog_bar.stop;
  end

  output.result_files = job_result_files;

end % block_var

function result_img = detrend(img)

  %%
  %% preallocate full size matrix
  %%
  num_scan = 0;
  num_vox = size(img{1},2);
  for blk = 1:numel(img)
    num_scan = num_scan + size(img{blk},1);
  end
  result_img = zeros(num_scan, num_vox);

  %%
  %% merge blocks and detrend block-wise
  %%
  cnt = 0;
  for blk = 1:numel(img)
    block_data = img{blk};
    block_data = 100 * block_data / mean(mean(block_data));
    block_mean = mean(block_data);
    vox = find(block_mean);
    for scn = 1:size(block_data,1)
      cnt = cnt + 1;
      result_img(cnt,vox) = block_data(scn,vox) - block_mean(vox);
    end
  end

end

